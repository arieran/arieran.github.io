<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="https://arieran.github.io/atom.xml" rel="self"/>
  
  <link href="https://arieran.github.io/"/>
  <updated>2023-07-21T14:05:14.967Z</updated>
  <id>https://arieran.github.io/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Earning.Farm攻击事件分析</title>
    <link href="https://arieran.github.io/2023/07/21/Earning-Farm%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90/"/>
    <id>https://arieran.github.io/2023/07/21/Earning-Farm%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90/</id>
    <published>2023-07-21T14:03:46.000Z</published>
    <updated>2023-07-21T14:05:14.967Z</updated>
    
    <content type="html"><![CDATA[<p>咱们小组成员写的文章，赞赞滴！！！又查了一点零时的分析，放在一起学习一哈</p><p>前面的背景直接cv了</p><h3 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h3><p>Earning Farm 是一款便利友好的投资软件，帮助用户管理加密资产。而在10月15日，Earning.Farm 的 <strong>EFLeverVault 合约</strong>遭到两次<strong>闪电贷攻击</strong>。其中第一笔攻击被 <strong>MEV bot</strong> 截获，损失 480 ETH，第二笔黑客完成攻击，获利 268 ETH，超过34万美元。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://ctfiot.oss-cn-beijing.aliyuncs.com/uploads/2022/10/3-1665834709.png"                      alt="img"                ></p><p>通过观察交易细节图，不难发现攻击者在调用了 <code>Balancer</code> 的 <code>flashloan</code> 之后，直接把闪电贷的接收人设置为 <code>EFVault</code> 合约，然后触发了 <code>EFVault</code> 的 <code>receiveFlashLoan</code> 函数，再继续就是攻击者调用 <code>withdraw</code> 函数，然后钱就神奇的去了攻击者的攻击合约里。那么这里头究竟发生了啥呢？</p><h3 id="攻击地址及交易信息"><a href="#攻击地址及交易信息" class="headerlink" title="攻击地址及交易信息"></a>攻击地址及交易信息</h3><blockquote><ul><li><p>攻击者账户地址：</p></li><li><p>0xdf31f4c8dc9548eb4c416af26dc396a25fde4d5f</p></li><li></li><li><p>攻击者合约地址：</p></li><li><p>0x140cca423081ed0366765f18fc9f5ed299699388</p></li><li></li><li><p>攻击交易：</p></li><li><p>0x160c5950a01b88953648ba90ec0a29b0c5383e055d35a7835d905c53a3dda01e</p></li><li></li></ul><p>​        被攻击合约地址：</p><p>​        0xe39fd820B58f83205Db1D9225f28105971c3D309</p></blockquote><h3 id="攻击过程"><a href="#攻击过程" class="headerlink" title="攻击过程"></a>攻击过程</h3><p>1.攻击者创建一个智能合约向balancer发送一个闪贷请求,贷款560Eth，闪贷接收者为被攻击的EFLeverVault合约.</p><p>![截屏2023-05-13 19.03.45](&#x2F;Users&#x2F;doumeili&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;截屏2023-05-13 19.03.45.png)</p><p>2.EFLeverVault的<code>receiveFlashLoan</code>回调触发，根据userData传入参数调用_withdraw函数计算得出大量获利833stETH</p><p>![截屏2023-05-13 19.06.55](&#x2F;Users&#x2F;doumeili&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;截屏2023-05-13 19.06.55.png)</p><p>3.归还560ETH之后，还剩273stETH。</p><p>![截屏2023-05-13 19.08.15](&#x2F;Users&#x2F;doumeili&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;截屏2023-05-13 19.08.15.png)</p><p>4.调用withdraw函数取出余额获利</p><p>![截屏2023-05-13 19.09.59](&#x2F;Users&#x2F;doumeili&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;截屏2023-05-13 19.09.59.png)</p><p>5.最后攻击者一共获利268.7ETH</p><p>![截屏2023-05-13 19.10.12](&#x2F;Users&#x2F;doumeili&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;截屏2023-05-13 19.10.12.png)</p><h3 id="“钥匙是对的，开门的是贼而已”"><a href="#“钥匙是对的，开门的是贼而已”" class="headerlink" title="“钥匙是对的，开门的是贼而已”"></a>“钥匙是对的，开门的是贼而已”</h3><h4 id="1、receiveFlashLoan"><a href="#1、receiveFlashLoan" class="headerlink" title="1、receiveFlashLoan"></a>1、<code>receiveFlashLoan</code></h4><p>首先根据这个流程来看。攻击者直接调用了 <code>EFVault</code> 的 <code>receiveFlashLoan</code> 函数，而这个函数一般是不允许合约以外的用户直接调用的，这就有点像是之前关于 <code>uniswapV2Call</code> 被任意调用导致的问题一样。但是光从这一点，还不能完全推断出究竟是什么问题导致的进一步的损失，所以，我们还需要结合 <code>receiveFlashLoan</code> 和 <code>withdraw</code> 的逻辑来继续具体看看。我们先看 <code>receiveFlashLoan</code> 的逻辑</p><blockquote><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function receiveFlashLoan(  </span><br><span class="line">         IERC20[] memory tokens,   </span><br><span class="line">         uint256[] memory amounts,      </span><br><span class="line">         uint256[] memory feeAmounts,     </span><br><span class="line">         bytes memory userData   </span><br><span class="line">         )public payable &#123;   </span><br><span class="line">         require(msg.sender == balancer, &quot;only flashloan vault&quot;);</span><br><span class="line">         uint256 loan_amount = amounts[0];    </span><br><span class="line">         uint256 fee_amount = feeAmounts[0];</span><br><span class="line">         if (keccak256(userData) == keccak256(&quot;0x1&quot;))&#123; </span><br><span class="line">         _deposit(loan_amount, fee_amount);    </span><br><span class="line">         &#125;      </span><br><span class="line">         if (keccak256(userData) == keccak256(&quot;0x2&quot;))&#123;</span><br><span class="line">         _withdraw(loan_amount, fee_amount);      </span><br><span class="line">         &#125;   </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></div></blockquote><p>通过观察该函数，不难发现 这个函数仅在 #L7 行对 <code>msg.sender</code> 进行了检查，**<u>而没有对调用该 <code>flashloan</code> 的地址进行检查。</u><strong>然后再根据 <code>userData</code> 来决定是调用 <code>_deposit</code> 函数还是 <code>_withdraw</code> 函数。到了这里，就很明显能发现，</strong><u>这是一个类似 <code>uniswapV2Call</code> 未鉴权的问题</u>**。通过查看攻击者在调用 <code>flashloan</code> 时传入的参数，可以判断出最后是调用了 <code>_withdraw</code> 函数.</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://ctfiot.oss-cn-beijing.aliyuncs.com/uploads/2022/10/6-1665834709.png"                      alt="img"                ></p><p>回顾上面的 <code>receiveFlashLoan</code> 逻辑，细心看看，检查的逻辑里用的是 <code>keccak256(&quot;0x2&quot;)</code> 而不是 <code>keccak256(0x2)</code> 这里是不一样的，前者相当于对 <code>&quot;0x2&quot;</code> 这个字符做了哈希，而不是对 <code>0x2</code> 这个 16 进制进行哈希，而 <code>&quot;0x2&quot;</code> 对应的 16 进制正好就是 <code>0x307832</code>。</p><p>![截屏2023-05-13 19.27.29](&#x2F;Users&#x2F;doumeili&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;截屏2023-05-13 19.27.29.png)</p><h4 id="2、-withdraw"><a href="#2、-withdraw" class="headerlink" title="2、_withdraw"></a>2、<code>_withdraw</code></h4><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function _withdraw(uint256 amount, uint256 fee_amount) </span><br><span class="line">internal&#123;</span><br><span class="line">    uint256 steth_amount = amount.safeMul(IERC20(asteth).balanceOf(address(this))).safeDiv(getDebt());</span><br><span class="line">    if (IERC20(weth).allowance(address(this), aave) != 0) &#123;IERC20(weth).safeApprove(aave, 0);&#125;</span><br><span class="line">    IERC20(weth).safeApprove(aave, amount);</span><br><span class="line"></span><br><span class="line">    IAAVE(aave).repay(weth, amount, 2, address(this));</span><br><span class="line">    IAAVE(aave).withdraw(lido, steth_amount, address(this));</span><br><span class="line"></span><br><span class="line">    if (IERC20(lido).allowance(address(this), curve_pool) != 0) &#123;IERC20(lido).safeApprove(curve_pool, 0);&#125;</span><br><span class="line">    IERC20(lido).safeApprove(curve_pool, steth_amount);</span><br><span class="line">    ICurve(curve_pool).exchange(1, 0, steth_amount, 0);</span><br><span class="line"></span><br><span class="line">    (bool status, ) = weth.call.value(amount.safeAdd(fee_amount))(&quot;&quot;);</span><br><span class="line">    require(status, &quot;transfer eth failed&quot;);</span><br><span class="line">    IERC20(weth).safeTransfer(balancer, amount.safeAdd(fee_amount));</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br></pre></td></tr></table></figure></div><p>通过分析代码逻辑， <code>_withdraw</code> 函数实际上就是根据参数中 <code>amount</code> 的大小把合约所持 <code>stETH</code> 从 <code>aave</code> 中提取出来(L2-7)，然后再把取出来的 <code>stETH</code> 再换成 <code>ETH</code>，再次存入到合约中。然后归还闪电贷。到这里，<code>_withdraw</code> 的代码逻辑我们就梳理完了。结合上文提到的，这里还不是攻击的终点，所以我们还要继续分析 <code>withdraw</code> 函数。</p><blockquote><p>我查了一下 网上文章里所描述的stETH和同学的weth是大致一样的。</p><p>![截屏2023-05-13 19.37.52](&#x2F;Users&#x2F;doumeili&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;截屏2023-05-13 19.37.52.png)</p></blockquote><p>再分析<code>withdraw</code>函数如下</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function withdraw(uint256 _amount) public nonReentrant&#123;</span><br><span class="line">    require(IERC20(ef_token).balanceOf(msg.sender) &gt;= _amount, &quot;not enough balance&quot;);</span><br><span class="line">    //...省略不重要逻辑</span><br><span class="line"></span><br><span class="line">    uint256 loan_amount = getDebt().safeMul(_amount).safeDiv(IERC20(ef_token).totalSupply());</span><br><span class="line">    </span><br><span class="line">    address[] memory tokens = new address[](1);</span><br><span class="line">    uint256[] memory amounts = new uint256[](1);</span><br><span class="line">    bytes memory userData = &quot;0x2&quot;;</span><br><span class="line">    tokens[0] = weth;</span><br><span class="line">    amounts[0] = loan_amount;</span><br><span class="line">    //uint256 user_eth_before = msg.sender.balance;</span><br><span class="line">    IBalancer(balancer).flashLoan(address(this), tokens, amounts, userData);</span><br><span class="line"></span><br><span class="line">    uint256 to_send = address(this).balance;</span><br><span class="line">    (bool status, ) = msg.sender.call.value(to_send)(&quot;&quot;);</span><br><span class="line">    require(status, &quot;transfer eth failed&quot;);</span><br><span class="line"></span><br><span class="line">    TokenInterfaceERC20(ef_token).destroyTokens(msg.sender, _amount);</span><br><span class="line">    emit CFFWithdraw(msg.sender, to_send, _amount, getVirtualPrice());</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></div><p>通过分析 <code>withdraw</code> 函数的逻辑。可以发现其实就是根据用户的 <code>ef_token</code> 的数量，通过 #L5 算出可以提取的份额，再通过发起闪电贷，并指定 <code>userData</code> 为 <code>&quot;0x2&quot;</code>。进行还款后，通过 #L15 的 <code>address(this).balance</code> 来确定剩余在合约中的 <code>ETH</code> 发还给用户。为什么这么判断呢？回顾上面上文，在 <code>withdraw</code> 函数被调用后，会调用 <code>_withdraw</code> 函数 在函数逻辑中，在归还闪电贷之后的资金会留在合约当中。那么根据这个逻辑，闪电贷结束后剩余的资金理应就是用户的资产。所以直接采用 <code>address(this).balance</code> 来判断是没有问题的.</p><p>⚠️【简单来说！外表看整个借贷还贷流程是没问题的！那么！问题出在哪里了呢 到底是哪里动了手脚呢！！】</p><p>💥但是问题在于攻击者打破了这个流程，</p><p>正常的流程应该是先 <code>withdraw</code>，</p><p> 通过 <code>withdraw</code> 触发 <code>_withdraw</code> 最后再用 <code>address(this).balance</code> 来判断剩余资金。</p><p>但由于合约在  <code>receiveFlashLoan</code> 函数中并没有检查闪电贷的发起者，导致 <code>receiveFlashLoan</code> 这个接口是可以被任意调用的，这个时候只需要构造控制参数中的 <code>amount</code> 变量，就可以把合约中的 <code>stETH</code> 全部提出，而由于归还闪电贷后的资金滞留在合约里，导致在调用 <code>withdraw</code> 函数的时候，合约通过 <code>address(this).balance</code> 判断的时候直接把资金判断成是用户的。最终导致了被盗。所以这里其实存在两个问题。</p><p><code>receiveFlashLoan</code> 被任意调用和余额判断用 <code>address(this).balance</code> 进行判断。其中后者是很多开发者容易忽略的问题，如果这里用的是用户真实的提现余额来判断的话，此次攻击事件中，就算在 <code>receiveFlashLoan</code> 存在问题的情况下，攻击者也无法把所有的资金全部提走。</p><h3 id="事件背后的思考"><a href="#事件背后的思考" class="headerlink" title="事件背后的思考"></a>事件背后的思考</h3><p>全文一直在提的就是 <code>receiveFlashLoan</code> 中没有检查闪电贷的发起者导致接口被任意调用，那么是不是可以通过检查发起人就可以避免这个问题呢？像 <code>uniswapV2Call</code> 那样？我们来看看 <code>Balancer Vault</code> 的逻辑：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">function flashLoan(</span><br><span class="line">        IFlashLoanRecipient recipient,</span><br><span class="line">        IERC20[] memory tokens,</span><br><span class="line">        uint256[] memory amounts,</span><br><span class="line">        bytes memory userData</span><br><span class="line">    ) external override nonReentrant whenNotPaused &#123;</span><br><span class="line">        //..省略不重要逻辑</span><br><span class="line"></span><br><span class="line">        for (uint256 i = 0; i &lt; tokens.length; ++i) &#123;</span><br><span class="line">            IERC20 token = tokens[i];</span><br><span class="line">            uint256 amount = amounts[i];</span><br><span class="line"></span><br><span class="line">            _require(token &gt; previousToken, token == IERC20(0) ? Errors.ZERO_TOKEN : Errors.UNSORTED_TOKENS);</span><br><span class="line">            previousToken = token;</span><br><span class="line"></span><br><span class="line">            preLoanBalances[i] = token.balanceOf(address(this));</span><br><span class="line">            feeAmounts[i] = _calculateFlashLoanFeeAmount(amount);</span><br><span class="line"></span><br><span class="line">            _require(preLoanBalances[i] &gt;= amount, Errors.INSUFFICIENT_FLASH_LOAN_BALANCE);</span><br><span class="line">            token.safeTransfer(address(recipient), amount);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        recipient.receiveFlashLoan(tokens, amounts, feeAmounts, userData);</span><br><span class="line">        </span><br><span class="line">        //..省略不重要逻辑</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><p>通过观察 <code>Balancer Vault</code> 的 <code>flashloan</code> 函数，可以发现函数里没有任何可以用于给资金接收人用于判断闪电贷发起人的参数，最类似的 <code>userData</code> 其实也是从函数参数里获取的，即是用户可控的。也就是说。这个函数如果你写在合约里，就是没办法写成是一个指定发起人才能调用的操作。那怎么办呢？难道就只能任人宰割了吗？并不，这里有几个方法：</p><blockquote><ol><li>确保有实现该方法的合约里，不存有任何资金</li><li>设置流程锁，以这次攻击为例子，必须在 <code>withdraw</code> 函数调用后，设置 <code>withdrawInProcess = true</code>，然后 <code>flashloan</code> 的时候检查到这个状态才允许继续提现。</li></ol></blockquote><p>引用一下：</p><blockquote><p>在分析的过程中，笔者同时注意到 <code>earing.farm</code> 是经过多轮审计的，但最后还是出现了这次的事件，由此我们可以得出，安全是一个动态变化的过程，并不是说某个版本进过了审计就表明已经是没有安全问题了。在安全世界里，每个项目方的状态应该都是已经被黑和在被黑的路上 😀</p></blockquote><p>！！！安全一直在路上 又十分重要 真的真的真的</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;咱们小组成员写的文章，赞赞滴！！！又查了一点零时的分析，放在一起学习一哈&lt;/p&gt;
&lt;p&gt;前面的背景直接cv了&lt;/p&gt;
&lt;h3 id=&quot;背景介绍&quot;&gt;&lt;a href=&quot;#背景介绍&quot; class=&quot;headerlink&quot; title=&quot;背景介绍&quot;&gt;&lt;/a&gt;背景介绍&lt;/h3&gt;&lt;p&gt;</summary>
      
    
    
    
    
    <category term="攻击事件分析" scheme="https://arieran.github.io/tags/%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>整数溢出学习</title>
    <link href="https://arieran.github.io/2023/07/21/%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA%E5%AD%A6%E4%B9%A0/"/>
    <id>https://arieran.github.io/2023/07/21/%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA%E5%AD%A6%E4%B9%A0/</id>
    <published>2023-07-21T14:00:38.000Z</published>
    <updated>2023-07-21T14:08:23.638Z</updated>
    
    <content type="html"><![CDATA[<h2 id="整数溢出"><a href="#整数溢出" class="headerlink" title="整数溢出"></a>整数溢出</h2><p>当时在进入小组考核的时候，记得这个基础漏洞，后续没有深究，现在看到又重新学习一下。结合小组成员文章和网络上的文章。</p><h3 id="0x01漏洞攻击事件"><a href="#0x01漏洞攻击事件" class="headerlink" title="0x01漏洞攻击事件"></a>0x01漏洞攻击事件</h3><p>2018年4月22日，黑客对BEC智能合约发起攻击，凭空取出：</p><p><strong>57,896,044,618,658,100,000,000,000,000,000,000,000,000,000,000,000,000,000,000.792003956564819968</strong> 个BEC代币并在市场上进行抛售，BEC随即急剧贬值，价值几乎为0，该市场瞬间土崩瓦解。</p><p>2018年4月25日，SMT项目方发现其交易存在异常，黑客利用其函数漏洞创造了：</p><p><strong>65,133,050,195,990,400,000,000,000,000,000,000,000,000,000,000,000,000,000,000+50,659,039,041,325,800,000,000,000,000,000,000,000,000,000,000,000,000,000,000</strong> 的SMT币，火币Pro随即暂停了所有币种的充值提取业务。</p><p>2018年12月27日，以太坊智能合约Fountain(FNT)出现整数溢出漏洞，黑客利用其函数漏洞创造了：</p><p><strong>2+115792089237316195423570985008687907853269984665640564039457584007913129639935</strong> 的SMT币。</p><p>历史的血泪教训，如今不该再次出现。让我们一起缅怀这些一夜归零的代币，吸取前人经验教训。</p><h3 id="0x02-整数溢出原理"><a href="#0x02-整数溢出原理" class="headerlink" title="0x02 整数溢出原理"></a>0x02 整数溢出原理</h3><ul><li><strong>整数溢出原理</strong></li></ul><p>由于计算机底层是二进制，任何十进制数字都会被编码到二进制。溢出会丢弃最高位，导致数值不正确。</p><p>如：八位无符号整数类型的最大值是 255，翻译到二进制是 1111 1111；当再加一时，当前所有的 1 都会变成 0，并向上进位。但由于该整数类型所能容纳的位置已经全部是 1 了，再向上进位，最高位会被丢弃，于是二进制就变成了 0000 0000</p><p>注：有符号的整数类型，其二进制最高位代表正负。所以该类型的正数溢出会变成负数，而不是零。（计组内容）</p><ul><li><strong>整数溢出示例（通用编程语言）</strong></li></ul><p>编程语言由算数导致的整数溢出漏洞司空见惯，其类型包括如下三种：</p><p>• 加法溢出</p><p>• 减法溢出</p><p>• 乘法溢出</p><p>我们先以运行在 JVM 上的 Kotlin 编程语言做加法运算来测试整数溢出为例：</p><div class="highlight-container" data-rel="Kotlin"><figure class="iseeu highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   println(<span class="built_in">Long</span>.MAX_VALUE + <span class="number">1</span>) <span class="comment">// Long 是有符号的 128 位 Integer 类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>程序会打印出 -9223372036854775808，这其实是<strong>在编译期就没有防止整数溢出</strong>，因为编译器让溢出的代码通过编译了。</p><p>当然，也有<strong>在编译期严格检查整数溢出的编程语言</strong>。如区块链世界最火的 Rust 编程语言：</p><div class="highlight-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    dbg!(u128::<span class="variable constant_">MAX</span> + <span class="number">1</span>); <span class="comment">// u128 是无符号的 128 位 Integer 类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>编译这段代码，你会得到编译错误：</p><div class="highlight-container" data-rel="Rust"><figure class="iseeu highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">error: this arithmetic operation will overflow</span><br><span class="line"> -<span class="punctuation">-&gt;</span> src/main.rs:<span class="number">2</span>:<span class="number">10</span></span><br><span class="line">  |</span><br><span class="line"><span class="number">2</span> |     dbg!(<span class="type">u128</span>::MAX + <span class="number">1</span>);</span><br><span class="line">  |          ^^^^^^^^^^^^^ attempt to compute `<span class="type">u128</span>::MAX + <span class="number">1_u128</span>`, which would overflow</span><br><span class="line">  |</span><br><span class="line">  = note: `<span class="meta">#[deny(arithmetic_overflow)]</span>` on by default</span><br></pre></td></tr></table></figure></div><p><strong>那么，如果是运行时呢？</strong>我们来读取用户输入试试：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let mut s = String::new();</span><br><span class="line">    std::io::stdin().read_line(&amp;mut s).unwrap();</span><br><span class="line">    dbg!(s.trim_end().parse::&lt;u8&gt;().unwrap() + 1); // u8 是无符号的 8 位 Integer 类型</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>运行 cargo r，输入：255，得到 panic：</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread <span class="string">&#x27;main&#x27;</span> panicked at <span class="string">&#x27;attempt to add with overflow&#x27;</span></span><br></pre></td></tr></table></figure></div><p>可以看到，在 debug 模式下，溢出会直接 panic，也就是：程序崩溃掉、停止工作。那么，release 模式下也是这样吗？</p><p>运行 cargo r –release，输入：255，打印：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[src/main.rs:4] s.trim_end().parse::&lt;u8&gt;().unwrap() + 1 = 0</span><br></pre></td></tr></table></figure></div><p>综上，我们得到一条结论：<strong>即使在编译期严格检查溢出的程序语言，依然会有整数溢出问题。</strong>整数溢出就好像是一个魔咒，总会隔三岔五地出现，无法一劳永逸地消除。</p><p>下面来看一下</p><ul><li><strong>智能合约中的整数溢出（Solidity 语言）</strong></li></ul><p>在区块链的世界里，智能合约的 Solidity 语言中，对于 0.8.0 以下的版本，也存在整数溢出问题。</p><p>和通用型编程语言一样，我们先看看编译期是否会发生溢出：</p><p>实测，测试函数会直接发生编译错误。再来看看运行时：</p><p>实测，程序会在运行时溢出。我们建议使用 SafeMath 库来解决漏洞溢出：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">library SafeMath &#123;</span><br><span class="line">  function mul(uint256 a, uint256 b) internal constant returns (uint256) &#123;</span><br><span class="line">    uint256 c = a * b;</span><br><span class="line">    assert(a == 0 || c / a == b);</span><br><span class="line">    return c;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function div(uint256 a, uint256 b) internal constant returns (uint256) &#123;</span><br><span class="line">    uint256 c = a / b;</span><br><span class="line">    return c;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function sub(uint256 a, uint256 b) internal constant returns (uint256) &#123;</span><br><span class="line">    assert(b &lt;= a);</span><br><span class="line">    return a - b;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function add(uint256 a, uint256 b) internal constant returns (uint256) &#123;</span><br><span class="line">    uint256 c = a + b;</span><br><span class="line">    assert(c &gt;= a);</span><br><span class="line">    return c;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>对于 Solidity 0.8.0 以上的版本，官方已经修复了这个问题。那么它到底是如何修复的？将要溢出时会发生什么来防止溢出呢？</p><p>实测，Solidity 0.8 以上的版本发生运行时溢出会直接 revert。</p><p>原来，修复的方式就是不允许溢出。int256 足够大，只要保证无法被黑客利用这一点凭空创造收益，我们就成功了。</p><h3 id="0x03-漏洞合约和攻击手法"><a href="#0x03-漏洞合约和攻击手法" class="headerlink" title="0x03 漏洞合约和攻击手法"></a>0x03 漏洞合约和攻击手法</h3><p>以 BEC 合约为例，合约地址为：</p><p><em>0xC5d105E63711398aF9bbff092d4B6769C82F793D</em></p><p>在 etherscan 上的地址为：</p><p><em><a class="link"   href="https://etherscan.io/address/0xc5d105e63711398af9bbff092d4b6769c82f793d#code" >https://etherscan.io/address/0xc5d105e63711398af9bbff092d4b6769c82f793d#code <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></em></p><p>存在溢出漏洞的合约代码如下：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function batchTransfer(address[] _receivers, uint256 _value) public whenNotPaused returns (bool) &#123;</span><br><span class="line">    uint cnt = _receivers.length;</span><br><span class="line">    uint256 amount = uint256(cnt) * _value; //溢出点，这里存在整数溢出</span><br><span class="line">    require(cnt &gt; 0 &amp;&amp; cnt &lt;= 20);</span><br><span class="line">    require(_value &gt; 0 &amp;&amp; balances[msg.sender] &gt;= amount);</span><br><span class="line"></span><br><span class="line">    balances[msg.sender] = balances[msg.sender].sub(amount);</span><br><span class="line">    for (uint i = 0; i &lt; cnt; i++) &#123;</span><br><span class="line">        balances[_receivers[i]] = balances[_receivers[i]].add(_value);</span><br><span class="line">        Transfer(msg.sender, _receivers[i], _value);</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><p>当时的合约版本是 ^0.4.16，小于 0.8 版本，也没有使用 SafeMath 库，因此存在整数溢出问题。</p><p>黑客传入了一个极大的值（这里为2**255），通过乘法向上溢出，使得 amount（要转的总币数）溢出后变为一个很小的数字或者0（这里变成0），从而绕过 balances[msg.sender] &gt;&#x3D; amount 的检查代码，使得巨大 _value 数额的恶意转账得以成功。</p><p>实际攻击的恶意转账记录：</p><p><em><a class="link"   href="https://etherscan.io/tx/0xad89ff16fd1ebe3a0a7cf4ed282302c06626c1af33221ebe0d3a470aba4a660f" >https://etherscan.io/tx/0xad89ff16fd1ebe3a0a7cf4ed282302c06626c1af33221ebe0d3a470aba4a660f <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></em></p><h3 id="0x04-漏洞案例"><a href="#0x04-漏洞案例" class="headerlink" title="0x04 漏洞案例"></a>0x04 漏洞案例</h3><p>这里跟着李碧友的做了一遍</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.21;</span><br><span class="line"></span><br><span class="line">contract TokenSaleChallenge &#123;</span><br><span class="line">    mapping(address =&gt; uint256) public balanceOf;</span><br><span class="line">    uint256 constant PRICE_PER_TOKEN = 1 ether;</span><br><span class="line"></span><br><span class="line">    function TokenSaleChallenge(address _player) public payable &#123;</span><br><span class="line">        require(msg.value == 1 ether);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function isComplete() public view returns (bool) &#123;</span><br><span class="line">        return address(this).balance &lt; 1 ether;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function buy(uint256 numTokens) public payable &#123;</span><br><span class="line">        require(msg.value == numTokens * PRICE_PER_TOKEN);</span><br><span class="line"></span><br><span class="line">        balanceOf[msg.sender] += numTokens;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function sell(uint256 numTokens) public &#123;</span><br><span class="line">        require(balanceOf[msg.sender] &gt;= numTokens);</span><br><span class="line"></span><br><span class="line">        balanceOf[msg.sender] -= numTokens;</span><br><span class="line">        msg.sender.transfer(numTokens * PRICE_PER_TOKEN);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure></div><p>用相同的钱来买相同的代币是行不通的—-</p><p>因为 <code>buy</code> 函数中的<code>require(msg.value == numTokens * PRICE_PER_TOKEN); balanceOf[msg.sender] += numTokens;</code> </p><p>和 <code>sell</code> 函数中的 <code>require(balanceOf[msg.sender] &gt;= numTokens); balanceOf[msg.sender] -= numTokens;</code> </p><p>限制了你存多少取多少，不能存少取多</p><p>我们就要存少，存少就要涉及到溢出。让 <code>require(msg.value == numTokens * PRICE_PER_TOKEN);</code> 中的<code>numTokens * PRICE_PER_TOKEN</code> 发生溢出，我们就可以实现花费少的主币获取更多的代币。</p><p>算一下溢出的门槛</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//115792089237316195423570985008687907853269984665640564039457584007913129639935</span><br><span class="line"> uint256 result = 2256 - 1;</span><br><span class="line"> //115792089237316195423570985008687907853269984665640564039457</span><br><span class="line"> uint256 temp = result / 1018;</span><br><span class="line"> // 此时给temp 的值加 1 应该是触发溢出的最低门槛</span><br><span class="line"> uint256 money = (temp + 1) * 10**18; //money=415992086870360064</span><br></pre></td></tr></table></figure></div><h3 id="0x05-总结"><a href="#0x05-总结" class="headerlink" title="0x05 总结"></a>0x05 总结</h3><p>在 Solidity 0.8 版本以下，且未使用 SafeMath 库的情况下：黑客往往会利用溢出构造一个极小值&#x2F;极大值，从而绕过某些检查，使巨额恶意转账得以成功。</p><p>当然，合约漏洞不仅仅只有整数溢出。除了开发者自身提高安全开发意识外，寻找专业的安全团队对合约进行全面的审计也是非常有必要的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;整数溢出&quot;&gt;&lt;a href=&quot;#整数溢出&quot; class=&quot;headerlink&quot; title=&quot;整数溢出&quot;&gt;&lt;/a&gt;整数溢出&lt;/h2&gt;&lt;p&gt;当时在进入小组考核的时候，记得这个基础漏洞，后续没有深究，现在看到又重新学习一下。结合小组成员文章和网络上的文章。&lt;/p&gt;
</summary>
      
    
    
    
    
    <category term="漏洞攻击" scheme="https://arieran.github.io/tags/%E6%BC%8F%E6%B4%9E%E6%94%BB%E5%87%BB/"/>
    
  </entry>
  
  <entry>
    <title>区块链安全入门</title>
    <link href="https://arieran.github.io/2023/07/21/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%AE%89%E5%85%A8%E5%85%A5%E9%97%A8/"/>
    <id>https://arieran.github.io/2023/07/21/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%AE%89%E5%85%A8%E5%85%A5%E9%97%A8/</id>
    <published>2023-07-21T13:54:06.000Z</published>
    <updated>2023-07-21T13:58:10.616Z</updated>
    
    <content type="html"><![CDATA[<h1 id="区块链安全入门"><a href="#区块链安全入门" class="headerlink" title="区块链安全入门"></a>区块链安全入门</h1><p>因为本人不是区块链出身，所以学习区块链安全之前先入门一下。上学期学的也比较乱，系统从头学习一下。</p><p>像一个区块链字典一样，可以随时查询，后面的攻击手法，等刷靶场的时候可以作为一个案例插进去。</p><p>文章参考：<a class="link"   href="https://paper.seebug.org/973/" >https://paper.seebug.org/973/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><h3 id="一、区块链安全相关名词"><a href="#一、区块链安全相关名词" class="headerlink" title="一、区块链安全相关名词"></a>一、区块链安全相关名词</h3><h3 id="钱包-Wallet"><a href="#钱包-Wallet" class="headerlink" title="钱包 Wallet"></a>钱包 Wallet</h3><p>钱包(Wallet)是一个<strong>管理私钥的工具</strong>，数字货币钱包形式多样，但它通常包含一个软件客户端，允许使用者通过钱包检查、存储、交易其持有的数字货币。它是进入区块链世界的基础设施和重要入口。</p><p>据 SlowMist Hacked 统计，仅 2018 年因“钓鱼”、“第三方劫持”等原因所造成的钱包被黑损失总金额就达 69,160,985 美元，深究根本，除了部分钱包本身对攻击防御的不全面之外，最主要的是钱包持有者们的安全防范意识不强。</p><h3 id="冷钱包-Cold-Wallet"><a href="#冷钱包-Cold-Wallet" class="headerlink" title="冷钱包 Cold Wallet"></a>冷钱包 Cold Wallet</h3><p>冷钱包(Cold Wallet)是一种<strong>脱离网络连接的离线钱包</strong>，将数字货币进行离线储存的钱包。使用者在一台离线的钱包上面生成数字货币地址和私钥，再将其保存起来。冷钱包是在不需要任何网络的情况下进行数字货币的储存，因此黑客是很难进入钱包获得私钥的，但它也不是绝对安全的，<strong>随机数不安全也会导致这个冷钱包不安全</strong>，此外硬件损坏、丢失也有可能造成数字货币的损失，因此需要做好密钥的备份。</p><h3 id="热钱包-Hot-Wallet"><a href="#热钱包-Hot-Wallet" class="headerlink" title="热钱包 Hot Wallet"></a>热钱包 Hot Wallet</h3><p>热钱包(Hot Wallet)是一种需要网络连接的在线钱包，在使用上更加方便。但由于热钱包一般需要在线使用，个人的电子设备<strong>有可能因误点钓鱼网站被黑客盗取钱包文件、捕获钱包密码或是破解加密私钥</strong>，而部分中心化管理钱包也并非绝对安全。因此在使用中心化交易所或钱包时，最好在不同平台设置不同密码，且开启二次认证，以确保自己的资产安全。</p><h3 id="公钥-Public-Key"><a href="#公钥-Public-Key" class="headerlink" title="公钥 Public Key"></a>公钥 Public Key</h3><p>公钥(Public Key)是和私钥成对出现的，<strong>和私钥一起组成一个密钥对</strong>，保存在钱包中。公钥由私钥生成，但是无法通过公钥倒推得到私钥。公钥能够通过一系列算法运算得到钱包的地址，因此可以作为拥有这个钱包地址的凭证。</p><h3 id="私钥-Private-Key"><a href="#私钥-Private-Key" class="headerlink" title="私钥 Private Key"></a>私钥 Private Key</h3><p><strong>私钥(Private Key)是一串由随机算法生成的数据，它可以通过非对称加密算法算出公钥，公钥可以再算出币的地址。</strong>私钥是非常重要的，作为密码，除了地址的所有者之外，都被隐藏。区块链资产实际在区块链上，所有者实际只拥有私钥，并通过私钥对区块链的资产拥有绝对控制权，因此，<strong>区块链资产安全的核心问题在于私钥的存储，拥有者需做好安全保管。</strong></p><p>和传统的用户名、密码形式相比，使用公钥和私钥交易最大的优点在于提高了数据传递的安全性和完整性，因为两者——对应的关系，用户基本不用担心数据在传递过程中被黑客中途截取或修改的可能性。同时，也因为私钥加密必须由它生成的公钥解密，发送者也不用担心数据被他人伪造。</p><h3 id="助记词-Mnemonic"><a href="#助记词-Mnemonic" class="headerlink" title="助记词 Mnemonic"></a>助记词 Mnemonic</h3><p>由于私钥是一长串毫无意义的字符，比较难以记忆，因此出现了助记词(Mnemonic)。<strong>助记词是利用固定算法，将私钥转换成十多个常见的英文单词。</strong>助记词和私钥是互通的，可以相互转换，它只是作为区块链数字钱包私钥的友好格式。所以在此强调：助记词即私钥！由于它的明文性，不建议它以电子方式保存，而是抄写在物理介质上保管好，它和 Keystore 作为双重备份互为补充。</p><h3 id="Keystore"><a href="#Keystore" class="headerlink" title="Keystore"></a>Keystore</h3><p>Keystore 主要在以太坊钱包 App 中比较常见(比特币类似以太坊 Keystore 机制的是：BIP38)，是把私钥通过钱包密码再加密得来的，与助记词不同，一般可保存为文本或 JSON 格式存储。换句话说，<strong>Keystore 需要用钱包密码解密后才等同于私钥。</strong>因此，Keystore 需要配合钱包密码来使用，才能导入钱包。当黑客盗取 Keystore 后，在没有密码情况下, <strong>有可能通过暴力破解 Keystore 密码解开 Keystore</strong>，所以建议使用者在设置密码时稍微复杂些，比如带上特殊字符，至少 8 位以上，并安全存储。</p><blockquote><p>由于区块链技术的加持使得区块链数字钱包安全系数高于其他的数字钱包，其中最为关键的就是两点：防盗和防丢。相比于盗币事件原因的多样化，造成丢币事件发生的原因主要有五个类型：没有备份、备份遗失、忘记密码、备份错误以及设备丢失或损坏。因此，我们在备份一个区块链数字钱包的时候，对私钥、助记词、Keystore 一定要进行多重、多次备份，把丢币的风险扼杀在摇篮之中。最后为大家提供一份来自 imToken 总结的<strong>钱包安全“十不原则”</strong>：</p><ol><li>不使用未备份的钱包</li><li>不使用邮件传输或存储私钥</li><li>不使用微信收藏或云备份存储私钥</li><li>不要截屏或拍照保存私钥</li><li>不使用微信、QQ 传输私钥</li><li>不要将私钥告诉身边的人</li><li>不要将私钥发送到群里</li><li>不使用第三方提供的未知来源钱包应用</li><li>不使用他人提供的 Apple ID</li><li>不要将私钥导入未知的第三方网站</li></ol></blockquote><h3 id="公链-Public-Blockchain"><a href="#公链-Public-Blockchain" class="headerlink" title="公链 Public Blockchain"></a>公链 Public Blockchain</h3><p>公有链(Public Blockchain)简称公链，是指全世界任何人都可随时进入读取、任何人都能发送交易且能获得有效确认的共识区块链。<strong>公链通常被认为是完全去中心化的，链上数据都是公开透明的，不可更改，任何人都可以通过交易或挖矿读取和写入数据。</strong>一般会通过代币机制(Token)来鼓励参与者竞争记账，来确保数据的安全性。</p><p>由于要检测所有的公链的工作量非常大，只靠一家公司不可能监测整个区块链生态安全问题，这就导致了黑客极有可能在众多公链之中找寻到漏洞进行攻击。2017 年 4 月 1 日，Stellar 出现通胀漏洞，一名攻击者利用此漏洞制造了 22.5 亿的 Stellar 加密货币 XLM，当时价值约 1000 万美元。</p><h3 id="交易所-Exchange"><a href="#交易所-Exchange" class="headerlink" title="交易所 Exchange"></a>交易所 Exchange</h3><p>与买卖股票的证券交易所类似，区块链交易所即数字货币买卖交易的平台。数字货币交易所又分为中心化交易所和去中心化交易所。</p><p><strong>去中心化交易所：</strong>交易行为<strong>直接发生在区块链上</strong>，数字货币会直接发回使用者的钱包，或是保存在区块链上的智能合约。这样直接在链上交易的好处在于<strong>交易所不会持有用户大量的数字货币，所有的数字货币会储存在用户的钱包或平台的智能合约上。</strong>去中心化交易通过技术手段在信任层面去中心化，也可以说是无需信任，每笔交易都通过区块链进行<strong>公开透明</strong>，不负责保管用户的资产和私钥等信息，用户资金的所有权完全在自己手上，具有非常好的个人数据安全和隐私性。目前市面上的<strong>去中心化交易所有 WhaleEx、Bancor、dYdX</strong> 等</p><p><strong>中心化交易所：</strong>目前热门的交易所大多都是采用中心化技术的交易所，使用者通常是到平台上注册，并经过一连串的身份认证程序(KYC)后，就可以开始在上面交易数字货币。用户在使用中心化交易所时，其货币交换不见得会发生在区块链上，<strong>取而代之的可能仅是修改交易所数据库内的资产数字</strong>，用户看到的只是账面上数字的变化，交易所只要在用户提款时准备充足的数字货币可供汇出即可。<strong>当前的主流交易大部分是在中心化交易所内完成的，目前市面上的中心化交易所有币安，火币，OKEx 等</strong>。</p><p>由于交易所作为连接区块链世界和现实世界的枢纽，储存了大量数字货币，它非常容易成为黑客们觊觎的目标，截止目前全球数字货币交易所因安全问题而遭受损失金额已超过 29 亿美元(数据来源 SlowMist Hacked)。</p><h3 id="节点-Node"><a href="#节点-Node" class="headerlink" title="节点 Node"></a>节点 Node</h3><p>在传统互联网领域，企业所有的数据运行都集中在一个<strong>中心化的服务器</strong>中，那么这个服务器就是一个节点。由于区块链是去中心化的分布式数据库，是由千千万万个“小服务器”组成。<strong>区块链网络中的每一个节点，就相当于存储所有区块数据的每一台电脑或者服务器。</strong>（和计网中的服务器同）所有新区块的生产，以及交易的验证与记帐，并将其广播给全网同步，都由节点来完成。节点分为“全节点”和“轻节点”，全节点就是拥有全网所有的交易数据的节点，那么轻节点就是只拥有和自己相关的交易数据节点。由于每一个全节点都保留着全网数据，这意味着，其中一个节点出现问题，整个区块链网络世界也依旧能够安全运行，这也是去中心化的魅力所在。</p><h3 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h3><p><strong>远程过程调用(Remote Procedure Call，缩写为 RPC)是一个计算机通信协议。</strong>（见到的第一个协议！）以太坊 RPC 接口是以太坊节点与其他系统交互的窗口，<strong>以太坊提供了各种 RPC 调用：HTTP、IPC、WebSocket 等等</strong>。在以太坊源码中：</p><ul><li>server.go 是核心逻辑，负责 API 服务的注入，以及请求处理、返回；</li><li>http.go 实现 HTTP 的调用；</li><li>websocket.go 实现 WebSocket 的调用；</li><li>ipc.go 实现 IPC 的调用；</li><li>以太坊节点默认在 8545 端口提供了 JSON RPC 接口，数据传输采用 JSON 格式，可以执行 Web3 库的各种命令，可以向前端（例如 imToken、Mist 等钱包客户端）提供区块链上的信息。</li></ul><h3 id="以太坊黑色情人节漏洞-ETH-Black-Valentine’s-Day"><a href="#以太坊黑色情人节漏洞-ETH-Black-Valentine’s-Day" class="headerlink" title="以太坊黑色情人节漏洞 ETH Black Valentine’s Day"></a>以太坊黑色情人节漏洞 ETH Black Valentine’s Day</h3><p>攻击者利用以太坊节点 Geth&#x2F;Parity RPC API 鉴权缺陷，恶意调用 eth_sendTransaction 盗取代币，持续时间长达两年，单被盗的且还未转出的以太币价值就高达现价 2 千万美金(以当时 ETH 市值计算)，还有代币种类 164 种，总价值难以估计（很多代币还未上交易所正式发行）。</p><p>![截屏2023-07-15 16.06.40](&#x2F;Users&#x2F;doumeili&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;截屏2023-07-15 16.06.40.png)</p><p><strong>攻击过程</strong></p><p>慢雾安全团队综合受害者情报、Reddit 资讯及蜜罐日志分析，回溯攻击行为</p><p>可能为：</p><ul><li><p>全球扫描 8545 端口（HTTP JSON RPC API）、8546 端口（WebSocket JSON RPC API）等开放的以太坊节点，发送 eth_getBlockByNumber、eth_accounts、eth_getBalance 遍历区块高度、钱包地址及余额</p></li><li><p>不断重复调用 eth_sendTransaction 尝试将余额转账到攻击者的钱包</p></li><li><p>当正好碰上节点用户对自己的钱包执行 unlockAccount 时，在 duration 期间内无需再次输入密码为交易签名，此时攻击者的 eth_sendTransaction 调用将被正确执行，余额就进入攻击者的钱包里了</p></li></ul><p><strong>备注：</strong></p><blockquote><p>unlockAccount 函数介绍</p><p>该函数将使用密码从本地的 keystore 里提取 private key 并存储在内存中，函数第三个参数 duration 表示解密后 private key 在内存中保存的时间，默认是 300 秒；如果设置为 0，则表示永久存留在内存，直至 Geth&#x2F;Parity 退出。</p></blockquote><p><strong>攻击时间线</strong></p><p>我们在 Etherscan 上对攻击者钱包地址进行细致的分析，得到如下主要攻击时间线：</p><ul><li>2016&#x2F;02&#x2F;14 03:59:14 PM 第一次 IN（进账），这天是情人节</li><li>2016&#x2F;02&#x2F;16 06:33:30 PM 第二次 IN，时隔 2 天，猜测自动化攻击程序首次上线</li><li>2016&#x2F;05&#x2F;19 07:46:33 PM 第一次 OUT（出账），此时共 IN 51 笔</li><li>2016&#x2F;07&#x2F;20 06:35:57 PM 第二次 OUT，此时共 IN 57笔</li><li>2017&#x2F;05&#x2F;11 06:34:35 PM Shapeshift（知名交易所） IN 7 笔，跨度 71 天</li><li>2017&#x2F;06&#x2F;10 02:39:53 AM OUT 最后一笔，此时共 IN 约 207 笔</li><li>2017&#x2F;06&#x2F;21 07:46:49 AM f2pool（知名矿池） IN 36 笔，跨度 4 小时</li></ul><p><strong>影响态势</strong></p><p>通过慢雾安全团队独有的墨子（MOOZ）系统对全球约 42 亿 IPv4 空间进行扫描探测，发现暴露在公网且开启 RPC API 的以太坊节点有 1 万多个。这些节点都存在被直接盗币攻击的高风险。</p><p>![截屏2023-07-15 16.12.23](&#x2F;Users&#x2F;doumeili&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;截屏2023-07-15 16.12.23.png)</p><p><strong>防御建议</strong></p><ul><li><p>更改默认的 RPC API 端口，配置方法如：–rpcport 8377 或 –wsport 8378</p></li><li><p>更改 RPC API 监听地址为内网，配置方法如：–rpcaddr 192.168.0.100 或 –wsaddr 192.168.0.100</p></li><li><p>配置 iptables 限制对 RPC API 端口的访问，举例：只允许 192.168.0.101 访问 8545 端口：<br>iptables -A INPUT -s 192.168.0.101 -p TCP –dport 8545 -j ACCEPT<br>iptables -A INPUT -p TCP –dport 8545 -j DROP</p></li><li><p>账户信息（keystore）不要存放在节点上 （因为账户不在节点上，所以就不会用到 unlockAccount 了）</p></li><li><p>任何转账均用 web3 的 sendTransaction 和 sendRawTransaction 发送私钥签名过的 transaction</p></li><li><p>私钥物理隔离（如冷钱包、手工抄写）或者高强度加密存储并保障密钥的安全</p></li></ul><p>我们需要特别提下攻击者的手法，不知道大家有没有注意到，攻击的第一步为什么调用的是 eth_getBlockByNumber 来获取区块高度？<strong>这个调用的细节是：eth_getBlockByNumber(“0x00”, false)，如果区块高度不是最新的，那么这个调用就会报错，后续也就没必要执行钱包地址、余额等查询操作，因为余额不准确，且最后一步的转账操作肯定没法完成。</strong>这种攻击逻辑的设计，对于这个攻击场景来说是一种非常暴力美学的设计。</p><p>我们还对 RPC API 相关模块功能进行进一步分析，发现了一些潜在的安全风险，也是需要大家注意的，比如：<strong>如果 RPC API 启用了 personal 模块，就可以通过 personal_unlockAccount 方法爆破账户密码，假如爆破成功，就可以一次性实现解锁 + 转账。如果 RPC API 启用了 miner 模块，就可以通过 miner_setEtherbase 方法修改挖矿的钱包地址。</strong></p><h3 id="共识-Consensus"><a href="#共识-Consensus" class="headerlink" title="共识 Consensus"></a>共识 Consensus</h3><p>共识算法主要是<strong>解决分布式系统中，多个节点之间对某个状态达成一致性结果的问题</strong>。分布式系统由多个服务节点共同完成对事务的处理，分布式系统中多个副本对外呈现的数据状态需要保持一致性。由于节点的不可靠性和节点间通讯的不稳定性，甚至节点作恶，伪造信息，使得<strong>节点之间出现数据状态不一致性的问题</strong>。通过共识算法，可以将多个不可靠的单独节点组建成一个<strong>可靠的分布式系统，实现数据状态的一致性，提高系统的可靠性。</strong></p><p>区块链系统本身作为一个超大规模的分布式系统，但又与传统的分布式系统存在明显区别。由于它不依赖于任何一个中央权威，系统建立在去中心化的点对点网络基础之上，因此分散的节点需要就交易的有效与否达成一致，<strong>这就是共识算法发挥作用的地方，即确保所有节点都遵守协议规则并保证所有交易都以可靠的方式进行。</strong>由共识算法实现在分散的节点间对交易的处理顺序达成一致，这是共识算法在区块链系统中起到的最主要作用。</p><p>区块链系统中的共识算法还承担着区块链系统中激励模型和治理模型中的部分功能，为了解决在**对等网络中(P2P)**相互独立的节点如何达成一项决议问题的过程。简而言之，共识算法是在解决分布式系统中如何保持一致性的问题。</p><h3 id="工作量证明-PoW-Proof-of-Work"><a href="#工作量证明-PoW-Proof-of-Work" class="headerlink" title="工作量证明 PoW(Proof of Work)"></a>工作量证明 PoW(Proof of Work)</h3><p>PoW(Proof of Work)是历史上第一个成功的去中心化区块链共识算法。工作量证明是大多数人所熟悉的，被比特币、以太坊，莱特币等主流公链广泛使用。</p><p>工作量证明要求节点参与者执行计算密集型的任务，但是对于其他网络参与者来说易于验证。在比特币的例子中，矿工竞相向由整个网络维护的区块链账本中添加所收集到的交易，即区块。为了做到这一点，矿工必须第一个准确计算出“nonce”，这是一个添加在字符串末尾的数字，用来创建一个满足开头特定个数为零的哈希值。不过存在采矿的大量电力消耗和低交易吞吐量等缺点。</p><h3 id="权益证明-PoS-Proof-of-Stake"><a href="#权益证明-PoS-Proof-of-Stake" class="headerlink" title="权益证明 PoS(Proof of Stake)"></a>权益证明 PoS(Proof of Stake)</h3><p>PoS(Proof of Stake)——<strong>权益证明机制</strong>，一种主流的区块链共识算法，<strong>目的是为了让区块链里的分布式节点达成共识</strong>，它往往和工作量证明机制(Proof of Work)一起出现，两种都被认为是区块链共识算法里面的主流算法之一。作为一种算法，它通过持币人的同意来达成共识，目的是确定出新区块，这过程相对于 PoW，不需要硬件和电力，且效率更高。</p><p>PoS 共识中引入了 Stake 的概念，<strong>持币人将代币进行 Staking，要求所有的参与者抵押一部分他们所拥有的 Token 来验证交易，然后获得出块的机会，</strong>PoS 共识中会通过选举算法，按照持币量比例以及 Token 抵押时长，或者是一些其他的方式，选出打包区块的矿工。矿工在指定高度完成打包交易，生成新区块，并广播区块，广播的区块经过 PoS 共识中另外一道”门槛”，验证人验证交易，通过验证后，区块得到确认。这样一轮 PoS 的共识过程就进行完成了。权益证明通过长期绑定验证者的利益和整个网络的利益来阻止不良行为。锁定代币后，如果验证者存在欺诈性交易，那么他们所抵押的 Token 也会被削减。</p><p>PoS 的研究脚步还在不断前进，安全、性能和去中心化一直都是 PoS 所追求的方向，未来也将有更多 PoS 的项目落地。为了更好的观测公链运行状态，即时监测安全异常，慢雾在 EOS、BOSCORE、FIBOS、YOYOW、IoTeX、COSMOS 上都部署了 Safe Staking，落地扎根安全领域，关注节点的稳定与安全。</p><h3 id="委托权益证明-DPoS-Delegate-Proof-of-Stake"><a href="#委托权益证明-DPoS-Delegate-Proof-of-Stake" class="headerlink" title="委托权益证明 DPoS(Delegate Proof of Stake)"></a>委托权益证明 DPoS(Delegate Proof of Stake)</h3><p>委托权益证明，其雏形诞生在 2013 年 12 月 8 日，Daniel Larimer 在 bitsharetalk 首次谈及用投票选择出块人的方式，<strong>代替 PoS 中可能出现的选举随机数被操纵的问题</strong>。在 DPoS 中，让每一个持币者都可以进行投票，由此产生一定数量的代表 ,或者理解为一定数量的节点或矿池，他们彼此之间的权利是完全相等的。持币者可以随时通过投票更换这些代表，以维系链上系统的“长久纯洁性”。在某种程度上，这很像是国家治理里面的代议制，或者说是人大代表制度。这种制度最大的好处就是解决了验证人过多导致的效率低下问题，当然，这种制度也有很明显的缺点，由于 “代表”制度，导致其一直饱受中心化诟病。</p><h3 id="恶意挖矿攻击-Cryptojacking-Attack"><a href="#恶意挖矿攻击-Cryptojacking-Attack" class="headerlink" title="恶意挖矿攻击 Cryptojacking Attack"></a>恶意挖矿攻击 Cryptojacking Attack</h3><p>恶意挖矿攻击(Cryptojacking)是一种恶意行为，指未经授权的情况下劫持用户设备挖掘加密货币。通常，攻<strong>击者会劫持受害者设备(个人 PC 或服务器)的处理能力和带宽</strong>，由于加密货币挖掘需要大量算力，攻击者会尝试同时感染多个设备，这样他们能够收集到足够的算力来执行这种低风险和低成本的挖矿活动。</p><p>一般恶意挖矿软件会<strong>诱导用户在计算机上加载挖矿代码，或通过使用类似网络钓鱼的方法，如恶意链接、电子邮件或是在网站里植入挖矿脚本等方式，使系统无意中被隐藏的加密挖矿程序感染进而完成攻击行为。</strong>近年来，随着加密货币价格的上涨，更加复杂的恶意软件被开发出来，使恶意挖矿攻击事件层出不穷。</p><p>在此我们为大家提供几条建议防范恶意挖矿攻击：</p><ul><li>注意设备性能和 CPU 利用率</li><li>在 Web 浏览器上安装挖矿脚本隔离插件，例如 MinerBlock，NoCoin 和 Adblocker</li><li>小心电子邮件附件和链接</li><li>安装一个值得信赖的杀毒软件，让软件应用程序和操作系统保持最新状态</li></ul><h3 id="无利益攻击-Nothing-at-Stake-Attack"><a href="#无利益攻击-Nothing-at-Stake-Attack" class="headerlink" title="无利益攻击 Nothing at Stake Attack"></a>无利益攻击 Nothing at Stake Attack</h3><p>无利益攻击(Nothing at Stake Attack)，是在 PoS 共识机制下一个有待解决的问题，其问题的本质可以简单概括为<strong>“作恶无成本，好处无限多”。</strong></p><p>当 PoS 共识系统出现分叉(Fork)时，出块节点可以在“不受任何损失”的前提下，同时在两个分叉上出块；无论哪一个分叉后面被公认为主链，该节点都可以获得“所有收益”且不会有任何成本损失。这就很容易给某些节点一种动力去产生新的分叉，支持或发起不合法交易，其他逐利的出块节点会同时在多条链(窗口)上排队出块支持新的分叉。随着时间的推移，分叉越来越多，非法交易，作恶猖狂。区块链将不再是唯一链，所有出块节点没有办法达成共识。</p><p>为了预防这样的情况发生，许多类 PoS 共识机制对此的解决方法是引入惩罚机制，对作恶的节点进行经济惩罚(Slashing)，以建立更加稳定的网络。DPoS 实际上也是无利益攻击的解决方案之一，由上文我们可知 DPoS 这个机制由持币人选出出块节点来运营网络，出块节点会将一部分奖励分给投票者。</p><h3 id="多签-Multi-sig"><a href="#多签-Multi-sig" class="headerlink" title="多签 Multi-sig"></a>多签 Multi-sig</h3><p>多签(Multi-sig)指的是需要多个签名才能执行的操作(这些签名是不同私钥生成的)。这可用于提供更高的安全性，即使丢失单个私钥的话也不会让攻击者取得帐户的权限，多个值得信赖的各方必须同时批准更新，否则无效。</p><p>我们都知道，一般来说一个比特币地址对应一个私钥，动用这个地址中的资金需要私钥的持有者发起签名才行。而多重签名技术，简单来说，就是动用一笔资金时需要多个私钥签名才有效。多签的一个优势就是可以多方对一笔付款一起达成共识，才能支付成功。</p><h3 id="双花攻击-Double-Spend-Attack"><a href="#双花攻击-Double-Spend-Attack" class="headerlink" title="双花攻击 Double Spend Attack"></a>双花攻击 Double Spend Attack</h3><p>双花攻击(Double Spend Attack)即<strong>一笔钱花了两次，双重支付，利用货币的数字特性两次或多次使用“同一笔钱”完成支付。</strong>双花不会产生新的 Token，但能把自己花出去的钱重新拿回来。简单说就是，攻击者将一笔 Token 转到另外一个地址，通常是转到交易所进行套现，然后再<strong>利用一些攻击手法对转账交易进行回滚</strong>。目前有常见的几种手法能够引发双花攻击：</p><h5 id="1-Race-Attack"><a href="#1-Race-Attack" class="headerlink" title="1. Race Attack"></a>1. Race Attack</h5><p>这种攻击主要通过<strong>控制矿工费</strong>来实现双花。攻击者同时向网络中发送两笔交易，一笔交易发给自己(为了提高攻击成功的概率，他给这笔交易增加了足够的矿工费)，一笔交易发给商家。由于发送给自己的交易中含有较高的手续费，会被矿工优先打包进区块的概率比较高。这时候这笔交易就会先于发给商家的那笔交易，那么发给商家的交易就会被回滚。对于攻击者来说，通过控制矿工费，就实现了同一笔 Token 的“双花”。</p><h5 id="2-Finney-Attack"><a href="#2-Finney-Attack" class="headerlink" title="2. Finney Attack"></a>2. Finney Attack</h5><p>攻击者主要通过控制<strong>区块的广播时间</strong>来实现双花，攻击对象针对的是接受 0 确认的商家。假设攻击者挖到区块，该区块中包含着一个交易，即 A 向 B 转了一定数量的 Token，其中 A 和 B 都是攻击者的地址。但是攻击者并不广播这个区块，而是立即找到一个愿意接受 0 确认交易的商家向他购买一个物品，向商家发一笔交易，用 A 向商家的地址 C 支付，发给商家的交易广播出去后，攻击者再把自己之前挖到的区块广播出去，由于发给自己的交易先于发给商家的交易，对于攻击者来说，通过控制区块的广播时间，就实现了同一笔 Token 的“双花”。</p><h5 id="3-Vector76-attack"><a href="#3-Vector76-attack" class="headerlink" title="3. Vector76 attack"></a>3. Vector76 attack</h5><p>Vector76 Attack 又称“<strong>一次确认攻击</strong>”，也就是交易确认一次后仍然可以回滚，是 Finney Attack 和 Race Attack 的组合。</p><p><u>有点复杂</u></p><p>攻击者创建两个节点，节点 A 连接到商家节点，节点 B 连接到区块链网络中的其他节点。接着，攻击者用同一笔 Token 发起两笔交易，一笔交易发送给商家地址，我们称为交易 1；一笔交易发送给自己的钱包地址，我们称为交易 2。与上面说的 Race Attack 一样，攻击者对交易 2 添加了较高的矿工费从而提高了矿工的打包概率，此时，攻击者并没有把这两笔交易广播到网络中去。</p><p>接着，攻击者开始在交易 1 所在的分支上进行挖矿，这条分支我们命名为分支 1。攻击者挖到区块后，并没有广播出去，而是同时做了两件事：在节点 A 上发送交易 1，在节点 B 上发送交易 2。</p><p>由于节点 A 只连接了商家节点，所以当商家节点想把交易 1 传给其它对等节点时，连接了更多节点的节点 B，已经把交易 2 广播给了网络中的大部分节点。于是，从概率上来讲，交易 2 就更有可能被网络认定为是有效的，交易 1 被认定为无效。</p><p>交易 2 被认为有效后，攻击者立即把自己之前在分支 1 上挖到的区块，广播到网络中。这时候，这个接受一次确认就支付的商家，会确认交易成功，然后攻击者就可以立即变现并转移资产。</p><p>同时，由于分支 2 连接的更多节点，所以矿工在这个分支上挖出了另一个区块，也就是分支 2 的链长大于分支 1 的链长。于是，分支 1 上的交易就会回滚，商家之前支付给攻击者的交易信息就会被清除，但是攻击者早已经取款，实现了双花。</p><h5 id="4-51-attack"><a href="#4-51-attack" class="headerlink" title="4. 51% attack"></a>4. 51% attack</h5><p>攻击者占有超过全网 50% 的算力，在攻击者控制算力的这段时间，他可以创造一条高度大于原来链的新链。那么旧链中的交易会被回滚，攻击者可以使用同一笔 Token 发送一笔新的交易到新链上。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://images.seebug.org/content/images/2019/07/1f26cbd5-db82-4ea4-a16b-cc4e447171da.jpg-w331s"                      alt="img"                ></p><p>目前已知公链安全事件的攻击手法多为 51% 攻击，截止发稿日由于攻击者掌握大量算力发起 51% 攻击所造成的损失共 19,820,000 美金。2019 年 1 月 6 日，慢雾区预警了 ETC 网络的 51% 算力攻击的可能性，据 Coinbase 博客报道该攻击者总共发起了 15 次攻击，其中 12 次包含双花，共计被盗 219,500 ETC(按当时市价约为 110 万美元)，攻击者经过精心准备，通过租借大量算力向 ETC 发动了 51% 攻击，累计收益超 10 倍，Gate.io、Yobit、Bitrue 等交易所均受到影响。所幸在整个 ETC 生态社区的努力下，一周后攻击者归还了攻击所得收益，幸而没有造成进一步的损失。</p><h3 id="软分叉-Soft-fork"><a href="#软分叉-Soft-fork" class="headerlink" title="软分叉 Soft-fork"></a>软分叉 Soft-fork</h3><p>软分叉(Soft-fork)更多情况下是一种协议升级，当新共识规则发布后，没有升级的旧节点并不会意识到代码已经发生改变，而继续生产不合法的区块，就会产生临时性分叉，但新节点可以兼容旧节点，即新旧节点始终在同一条链上工作。（可兼容）</p><h3 id="硬分叉-Hard-fork"><a href="#硬分叉-Hard-fork" class="headerlink" title="硬分叉 Hard-fork"></a>硬分叉 Hard-fork</h3><p>（不可兼容）</p><p>硬分叉(Hard-fork)是区块链发生永久性分歧，在新共识规则发布后，已经升级的节点无法验证未升级节点产生的区块，未升级节点也无法验证已经升级的节点产生的区块，即新旧节点互不兼容，通常硬分叉就会发生，原有正常的一条链被分成了两条链（已升级的一条链和未升级的一条链，且这两条链互不兼容）。</p><p>历史上比较著名的硬分叉事件是 <strong>The DAO 事件</strong>，作为以太坊上的一个著名项目，由于智能合约的漏洞造成资金被黑客转移，黑客盗取了当时价值约 6000 万美元的 ETH，让这个项目蒙受了巨大的损失。为了弥补这个损失，2016 年 7 月，以太坊团队修改了以太坊合约代码实行硬分叉，在第 1920000 个区块强行把 The DAO 及其子 DAO 的所有资金全部转到一个特定的退款合约地址，进而“夺回”了黑客所控制 DAO 合约上的币。但这个修改被一部分矿工所拒绝，因而形成了两条链，**一条为原链(以太坊经典，ETC)，一条为新的分叉链(ETH)**，他们各自代表了不同社区的共识和价值观。</p><h3 id="异形攻击-Alien-Attack"><a href="#异形攻击-Alien-Attack" class="headerlink" title="异形攻击 Alien Attack"></a>异形攻击 Alien Attack</h3><p>异形攻击(Alien Attack)实际上是一个所有公链都可能面临的问题，又称<strong>地址池污染，是指诱使同类链的节点互相侵入和污染的一种攻击手法，漏洞的主要原因是同类链系统在通信协议上没有对不同链的节点做识别。</strong></p><p>这种攻击在一些参考以太坊通信协议实现的公链上得到了复现：以太坊同类链，由于使用了兼容的握手协议，无法区分节点是否属于同个链，利用这一点，攻击者先对以太坊节点地址进行收集并进行恶意握手操作，通过跟节点握手达成污染地址池的目的，使得不同链的节点互相握手并把各自地址池里已知的节点推送给了对方，导致更多的节点互相污染，最终扩散致整个网络。遭受异形攻击的节点通常会通信性能下降，最终造成节点阻塞、主网异常等现象。相关公链需要注意持续保持主网健康状态监测，以免出现影响主网稳定的攻击事件出现。</p><h3 id="钓鱼攻击-Phishing"><a href="#钓鱼攻击-Phishing" class="headerlink" title="钓鱼攻击 Phishing"></a>钓鱼攻击 Phishing</h3><p>所谓“钓鱼攻击(Phishing)”，指的是<strong>攻击者伪装成可以信任的人或机构，通过电子邮件、通讯软件、社交媒体等方式，以获取收件人的用户名、密码、私钥等私密信息。</strong>随着技术的发展，网络钓鱼攻击不仅可以托管各种恶意软件和勒索软件攻击，而且更糟糕的是这些攻击正在呈现不断上升的趋势。</p><p>2018 年 2 月 19 日，乌克兰的一个黑客组织，通过购买谷歌搜索引擎中与加密货币相关的关键词广告，伪装成合法网站的恶意网站链接，从知名加密货币钱包 Blockchain.info 中窃取了价值超过 5000 万美元的数字加密货币。而除了上述这种域名钓鱼攻击(即使用与官网相似的网址)外，其他类型的钓鱼攻击包括邮件钓鱼攻击、Twitter 1 for 10（支付 0.5-10ETH 返利 5-100ETH）、假 App 和假工作人员等。2019 年 6 月份，就有攻击者向多家交易所发送敲诈勒索信息，通过邮件钓鱼攻击获取了超 40 万美元的收益。</p><p>不要在通过点击链接到达的网站上输入凭据或私钥，在交易时尽可能的使用硬件钱包和双因素认证(2FA)，生态中的项目方在攻击者没有确切告知漏洞细节之前，不要给攻击者转账，若项目方无法准确判断和独自处理，可以联系安全公司协助处理。</p><h3 id="木马攻击-Trojan-Horse-Attack"><a href="#木马攻击-Trojan-Horse-Attack" class="headerlink" title="木马攻击 Trojan Horse Attack"></a>木马攻击 Trojan Horse Attack</h3><p>木马攻击(Trojan Horse Attack)是指攻击者通过<strong>隐藏在正常程序中的一段具有特殊功能的恶意代码</strong>，如具备破坏和删除文件、发送密码、记录键盘和 DDoS 攻击等特殊功能的后门程序，将控制程序寄生于被控制的计算机系统中，里应外合，对被感染木马病毒的计算机实施操作。可用来窃取用户个人信息，甚至是远程控制对方的计算机而加壳制作，然后通过各种手段传播或者骗取目标用户执行该程序，以达到盗取密码等各种数据资料等目的。</p><p>在区块链领域，诸如勒索木马、恶意挖矿木马一直是行业内令人头疼的安全顽疾，据币世界报道，随着比特币的飙升，推动整个数字加密货币价格回升，与币市密切相关的挖矿木马开始新一轮活跃，仅 2019 年上半年挖矿木马日均新增 6 万个样本，通过分析发现某些新的挖矿木马家族出现了快速、持续更新版本的现象，其功能设计越来越复杂，在隐藏手法、攻击手法方面不断创新，与杀软厂商的技术对抗正在不断增强。</p><h3 id="供应链攻击-Supply-Chain-Attack"><a href="#供应链攻击-Supply-Chain-Attack" class="headerlink" title="供应链攻击 Supply Chain Attack"></a>供应链攻击 Supply Chain Attack</h3><p>供应链攻击(Supply Chain Attack)是一种非常可怕的攻击方式，防御上很难做到完美规避，由于现在的软件工程，各种包&#x2F;模块的依赖十分频繁、常见，而开发者们很难做到一一检查，默认都过于信任市面上流通的包管理器，这就导致了供应链攻击几乎已经成为必选攻击之一。把这种攻击称成为供应链攻击，是为了形象说明这种攻击是一种依赖关系，一个链条，任意环节被感染都会导致链条之后的所有环节出问题。</p><p>供应链攻击形式多样，它可能出现在任何环节。2018 年 11 月，Bitpay 旗下 Copay 遭遇供应链攻击事件，攻击者的攻击行为隐匿了两个月之久。攻击者通过污染 EvenStream(NPM 包)并在后门中留下针对 Copay 的相关变量数值，对 Copay 发起定向攻击从而窃取用户的私钥信息。而就在2019 年 6 月 4 日，NPM Inc 安全团队刚与 Komodo 联手成功挫败了一起典型的供应链攻击，保护了超过 1300 万美元的数字加密货币资产，攻击者将恶意程序包放入 Agama 的构建链中，通过这种手段来窃取钱包应用程序中使用的钱包私钥和其他登录密码。</p><p>供应链攻击防不胜防且不计代价，慢雾安全团队建议所有数字加密货币相关项目(如交易所、钱包、DApp 等)都应该强制至少一名核心技术完整审查一遍所有第三方模块，看看是否存在可疑代码，也可以通过抓包查看是否存在可疑请求。</p><h3 id="交易回滚攻击-Roll-Back-Attack"><a href="#交易回滚攻击-Roll-Back-Attack" class="headerlink" title="交易回滚攻击 Roll Back Attack"></a>交易回滚攻击 Roll Back Attack</h3><p>交易回滚攻击(Roll Back Attack)，故名思义，指的是能对交易的状态进行回滚。回滚具体是什么意思呢？回滚具体指的是将已经发生的状态恢复成它未发生时候的样子。那么，交易回滚的意思就是将已经发生的交易变成未发生的状态。<strong>即攻击者本来已经发生了支付动作，但是通过某些手段，让转账流程发生错误，从而回滚整个交易流程，达到交易回滚的目的，</strong>这种攻击手法多发于区块链上的的智能合约游戏当中，当用户的下注动作和合约的开奖动作在一个交易内的时候，即<strong>内联交易</strong>。攻击者就可以通过交易发生时检测智能合约的某些状态，获知开奖信息，根据开奖信息选择是否对下注交易进行回滚。</p><p>该攻击手法早期常用于 EOS DApp 上，后逐步向波场等其他公链蔓延，截止目前，已有 12 个 DApp 遭遇攻击，慢雾安全团队建议开发者们不要将用户的下注与开奖放在同一个交易内，防止攻击者通过检测智能合约中的开奖状态实现交易回滚攻击。</p><h3 id="交易排挤攻击-Transaction-Congestion-Attack"><a href="#交易排挤攻击-Transaction-Congestion-Attack" class="headerlink" title="交易排挤攻击 Transaction Congestion Attack"></a>交易排挤攻击 Transaction Congestion Attack</h3><p>交易排挤攻击(Transaction Congestion Attack)是针对 EOS 上的使用 defer 进行开奖的游戏合约的一种攻击手法，<strong>攻击者可以通过某些手段，在游戏合约的 defer 开奖交易前发送大量的 defer 交易，恶意侵占区块内的 CPU 资源，使得智能合约内本应在指定区块内执行的 defer 开奖交易因资源不足无法执行，只能去到下一个区块才执行。</strong>由于很多 EOS 上的游戏智能合约使用区块信息作为智能合约本身的随机数，同一个 defer 开奖交易在不同区块内的执行结果是不一样的。通过这样的方式，<strong>攻击者在获知无法中奖的时候，就通过发送大量的 defer 交易，强行让智能合约重新开奖，从而达到攻击目的。</strong></p><p>该攻击手法最早在黑客 loveforlover 向 EOS.WIN 发起攻击时被发现，随后相同的攻击手法多次得手，据 SlowMist Hacked 统计仅 2019 年就有 22 个竞猜类 DApp 因此损失了大量资金，慢雾安全团队建议智能合约开发者对在不同区块内执行结果不同的关键的操作<strong>不要采用 defer 交易的方式</strong>，降低合约被攻击的风险。</p><h3 id="随机数攻击-Random-Number-Attack"><a href="#随机数攻击-Random-Number-Attack" class="headerlink" title="随机数攻击 Random Number Attack"></a>随机数攻击 Random Number Attack</h3><p>随机数攻击(Random Number Attack)，就是<strong>针对智能合约的随机数生成算法进行攻击，预测智能合约的随机数。</strong>目前区块链上很多游戏都是采用的链上信息（如区块时间，未来区块哈希等）作为游戏合约的随机数源，也称随机数种子。使用这种随机数种子生成的随机数被称为伪随机数。伪随机数不是真的随机数，存在被预测的可能。当使用可被预测的随机数种子生成随机数的时候，一旦随机数生成的算法被攻击者猜测到或通过逆向等其他方式拿到，攻击者就可以根据随机数的生成算法预测游戏即将出现的随机数，实现随机数预测，达到攻击目的。2018 年 11 月 11 日，攻击者向 EOS.WIN 发起连续随机数攻击，共获利 20,000 枚 EOS，在此慢雾安全团队建议智能合约开发者不要使用不安全的随机数种子生成随机数，降低合约被攻击的风险。</p><h3 id="hard-fail-状态攻击-hard-fail-Attack"><a href="#hard-fail-状态攻击-hard-fail-Attack" class="headerlink" title="hard_fail 状态攻击 hard_fail Attack"></a>hard_fail 状态攻击 hard_fail Attack</h3><p>hard_fail 是什么呢？<strong>简单来说就是出现错误但是没有使用错误处理器(error handler)处理错误，比方说使用 onerror 捕获处理，如果说没有 onerror 捕获，就会 hard_fail。</strong>EOS 上的交易状态记录分为 executed, soft_fail, hard_fail, delayed 和 expired 这 5 种状态，通常在链上大部分人观察到的交易，都是 executed 的，或者 delayed 的，而没有失败的交易，这就导致大部分开发者误以为 EOS 链上没有失败的交易记录，从而忽略了对交易状态的检查。攻击者利用这个细节，针对链上游戏或交易所进行攻击，构造执行状态为 hard_fail 的交易，欺骗链上游戏或交易所进行假充值攻击，从而获利。</p><p>该攻击手法最早由慢雾安全团队于 2019 年 3 月 10 日一款 EOS DApp 上捕获，帐号名为 fortherest12 的攻击者通过 hard_fail 状态攻击手法攻击了 EOS 游戏 Vegas town。随后，相同攻击手法频频发生，慢雾安全团队在此提醒交易所和 EOS DApp 游戏开发者在处理转账交易的时候需要严格校验交易状态，确保交易执行状态为 executed。</p><h3 id="重放攻击-Replay-Attack"><a href="#重放攻击-Replay-Attack" class="headerlink" title="重放攻击 Replay Attack"></a>重放攻击 Replay Attack</h3><p>重放攻击(Replay Attack)，是针对区块链上的交易信息进行重放，一般来说，区块链为了保证不可篡改和防止双花攻击的发生，会对交易进行各种验证，包括交易的时间戳，nonce，交易 id 等，但是随着各种去中心化交易所的兴起，在智能合约中验证用户交易的场景越来越多。这种场景一般是需要用户对某一条消息进行签名后上传给智能合约，然后在合约内部进行验签。但由于用户的签名信息是会上链的，也就是说每个人都能拿到用户的签名信息，当在合约中校验用户签名的时候，<strong>如果被签名的消息不存在随着交易次数变化的变量，如时间戳，nonce 等，攻击者就可以拿着用户的签名，伪造用户发起交易，从而获利</strong>。</p><p>这是一种最早出现于 DApp 生态初期的攻击形态，由于开发者设计的开奖随机算法存在严重缺陷，使得攻击者可利用合约漏洞重复开奖，属于开发者较为容易忽略的错误。因此，开发者们在链上进行验签操作的时候，需要对被签名消息加上各种可变因子，防止攻击者对链上签名进行重放，造成资产损失。</p><h3 id="重入攻击-Reentrancy-Attack"><a href="#重入攻击-Reentrancy-Attack" class="headerlink" title="重入攻击 Reentrancy Attack"></a>重入攻击 Reentrancy Attack</h3><p>重入攻击(Reentrancy Attack)首次出现于以太坊，对应的真实攻击为 The DAO 攻击，此次攻击还导致了原来的以太坊分叉成以太经典(ETC)和现在的以太坊(ETH)。<strong>由于项目方采用的转账模型为先给用户发送转账然后才对用户的余额状态进行修改，导致恶意用户可以构造恶意合约，在接受转账的同时再次调用项目方的转账函数。利用这样的方法，导致用户的余额状态一直没有被改变，却能一直提取项目方资金，最终导致项目方资金被耗光</strong>。</p><p>慢雾安全团队在此提醒智能合约开发者在进行智能合约开发时，在处理转账等关键操作的时候，如果智能合约中存储了用户的资金状态，<strong>要先对资金状态进行修改，然后再进行实际的资金转账，避免重入攻击。</strong></p><h3 id="假充值攻击-False-Top-up"><a href="#假充值攻击-False-Top-up" class="headerlink" title="假充值攻击 False Top-up"></a>假充值攻击 False Top-up</h3><p>假充值攻击(False Top-up)，分为针对智能合约的假充值攻击和对交易所的假充值攻击。在假充值攻击中，无论是智能合约还是交易所本身，<strong>都没有收到真实的 Token，但是用户又确实得到了真实的充值记录，</strong>在这种情况下，用户就可以在没有真正充值的情况下从智能合约或交易所中用假资产或不存在的资产窃取真实资产。</p><ol><li><p>智能合约假充值攻击</p><p>针对智能合约的假充值主要是<strong>假币的假充值</strong>，这种攻击手法多发于 EOS 和波场上，由于 EOS 上代币都是采用合约的方式进行发行的，EOS 链的系统代币同样也是使用这种方式发行，同时，任何人也可以发行名为 EOS 的代币。只是发行的合约帐号不一样，系统代币的发行合约为 “eosio.token”，而其他人发行的代币来源于其他合约帐号。当合约内没有校验 EOS 代币的来源合约的时候，攻击者就能通过充值攻击者自己发布的 EOS 代币，对合约进行假充值攻击。而波场上的假充值攻击主要是 TRC10 代币的假充值攻击，由于每一个 TRC10 都有一个特定的 tokenid 进行识别，当合约内没有对 tokenid 进行校验的时候，任何人都可以以 1024 个 TRX 发行一个 TRC10 代币对合约进行假充值。</p></li><li><p>交易所假充值攻击</p><p><strong>针对交易所的假充值攻击分为假币攻击和交易状态失败的假充值攻击</strong>。以 EOS 和以太坊为例。针对 EOS 可以使用名为 EOS 的假币的方式对交易所进行假充值攻击，如果交易所没有严格校验 EOS 的来源合约为 “eosio.token”，攻击就会发生。同时，区别于 EOS，由于以太坊上会保留交易失败的记录，针对 ERC20 Token，如果交易所没有校验交易的状态，就能通过失败的交易对交易所进行 ERC20 假充值。除此之外，hard_fail 状态攻击也是属于假充值攻击的一种。</p><p>慢雾安全团队在此建议交易所和智能合约开发者在处理转账的时候要充分校验交易的状态，如果是 EOS 或波场上的交易，在处理充值时还要同时校验来源合约是否是 “eosio.token” 或 tokenid 是否为指定的 tokenid。</p></li></ol><h3 id="短地址攻击-Short-Address-Attack"><a href="#短地址攻击-Short-Address-Attack" class="headerlink" title="短地址攻击 Short Address Attack"></a>短地址攻击 Short Address Attack</h3><p>短地址攻击(Short Address Attack)是针对以太坊上 ERC20 智能合约的一种攻击形式，利用的是 EVM 中的对于<strong>输入字节码的自动补全机制</strong>进行攻击。</p><p>一般而言，针对 ERC20 合约中的 transfer 函数的调用，输入的字节码位数都是 136 字节的。当调用 ERC20 中的 transfer 函数进行 ERC20 Token 转账时，如果攻击者提供的地址后有一个或多个 0，那么攻击者就可以把地址后的零省去，提供一个缺位的地址。当对这个地址转账的时候，比方说转账 100 的 A Token，然后输入的地址是攻击者提供的缺位地址，这时候，经过编码输入的数据是 134 字节，比正常的数据少了 2 字节，在这种情况下，EVM 就会对缺失的字节位在编码数据的末尾进行补 0 凑成 136 字节，<strong>这样本来地址段缺失的 0 被数据段的 0 补齐了，而由于给地址段补 0，数据段会少 0，而数据段缺失的 0 由 EVM 自动补齐，这就像数据段向地址段移动补齐地址段缺失字节位，然后数据段缺失的字节位由 EVM 用 0 补齐。这种情况下，转账金额就会由 100 变成 100 * 16 的 n 次方，n 是地址缺失的 0 的个数。</strong>（这里有点没懂 希望遇到实例）通过这种方式，攻击者就能对交易所或钱包进行攻击，盗窃交易所和钱包的资产。</p><p>进一步理解：<a class="link"   href="https://mp.weixin.qq.com/s?__biz=MzU4ODQ3NTM2OA==&mid=2247483970&idx=1&sn=3d826edc1b138194c6427943030b00e9&chksm=fddd7cc5caaaf5d374430877ad7fa8eef2a1bb5162d9e591bdd253cf35ba52eec7f34acd7a1e&scene=21#wechat_redirect" >https://mp.weixin.qq.com/s?__biz=MzU4ODQ3NTM2OA==&amp;mid=2247483970&amp;idx=1&amp;sn=3d826edc1b138194c6427943030b00e9&amp;chksm=fddd7cc5caaaf5d374430877ad7fa8eef2a1bb5162d9e591bdd253cf35ba52eec7f34acd7a1e&amp;scene=21#wechat_redirect <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><ul><li><input disabled="" type="checkbox"> 复现</li></ul><h3 id="假币攻击-Fake-Token-Attack"><a href="#假币攻击-Fake-Token-Attack" class="headerlink" title="假币攻击 Fake Token Attack"></a>假币攻击 Fake Token Attack</h3><p>假币攻击(Fake Token Attack)，是针对那些在创建官方 Token 时采用通用创建模版创建出来的代币，每个 Token 的识别仅根据特定的标记进行识别，如 EOS 官方 Token 的识别标记是 “eosio.token”合约，波场的 TRC10 的识别标记是 tokenid，以太坊的 ERC20 是用合约地址作为识别标记。那么这样就会出现一个问题，<strong>如果收款方在对这些 Token 进行收款的时候没有严格校验这些 Token 特有的标记，攻击就会发生</strong>，以 EOS 为例子，由于 EOS 官方 Token 采用的是合约来发行一个名为 EOS 的 Token，标记 EOS 本身的标识是 “eosio.token” 这个发行帐号，如果在接受转账的时候没有校验这个标识，攻击者就能用其他的帐号同样发行一个名为 EOS 的 Token，对交易所或钱包进行假币充值，换取真的代币。</p><p>2019 年 4 月 11 日，波场 Dapp TronBank 1 小时内被盗走约 1.7 亿枚 BTT（价值约 85 万元）。监测显示，黑客创建了名为 BTTx 的假币向合约发起“ invest ”函数，而合约并没有判定发送者的代币 id 是否与 BTT 真币的 id 1002000 一致。因此黑客拿到真币 BTT 的投资回报和推荐奖励，以此方式迅速掏空资金池。对此，交易所和钱包在处理转账的时候，切记要严格检验各种代币各种标识，防止假币攻击。</p><h3 id="整型溢出攻击-Integer-Overflow-Attack"><a href="#整型溢出攻击-Integer-Overflow-Attack" class="headerlink" title="整型溢出攻击 Integer Overflow Attack"></a>整型溢出攻击 Integer Overflow Attack</h3><p>数据的存储是区块链上重要的一环。但是每个数据类型本身是存在边界的，例如以太坊中 uint8 类型的变量就只能存储 0～255 大小的数据，超过了就存不下了。那么如果要放一个超过数据类型大小的数字会怎样呢？例如把 256 存进 uint8 的数据类型中，数据显示出来会变成 1，而不是其他数值，也不会报错，因为 uint8 本身能存一个 8 位二进制数字，最大值为 11111111，如果这个时候加 1，这个二进制数就变成了 100000001，而因为数据边界的关系，只能拿到后 8 位，也就是 00000001，那么数字的大小就变成 1 了，这种情况我们称为<strong>上溢</strong>。有上就有下，<strong>下溢</strong>的意思就是一个<strong>值为 0 的 uint8</strong> 数据，如果这个时候对它进行减 1 操作，结果会变成该数据类型所能存储的最大值加 1 减去被减数，在这个例子中是 255，也就是该数据类型所能存储的最大值。那么如果上述两种情况发生在智能合约当中的话，恶意用户通过下溢的操作，操纵自己的帐号向其他帐号发送超过自己余额数量的代币，如果合约内没有对余额进行检查，恶意用户的余额就会下溢出变成一个超大的值，这个时候攻击者如果大量抛售这些代币，就能瞬间破坏整个代币的价值系统。</p><h3 id="条件竞争攻击-Race-Condition"><a href="#条件竞争攻击-Race-Condition" class="headerlink" title="条件竞争攻击 Race Condition"></a>条件竞争攻击 Race Condition</h3><p>条件竞争(Race Condition)攻击的方式很多样，但是核心的本质无非是对某个条件的状态修改的竞争，如上期介绍的重入漏洞，也是条件竞争的一种，针对的是用户余额这个条件进行竞争，只要用户的余额没有归零，用户就能一直提走智能合约的钱。这次介绍的条件竞争的例子是最近发生的著名的 Edgeware 锁仓合约的拒绝服务漏洞，详情可参考：<a class="link"   href="http://mp.weixin.qq.com/s?__biz=MzU4ODQ3NTM2OA==&mid=2247484631&idx=2&sn=42b1cc849ed6a25d35bb24ed669af642&chksm=fddd7a50caaaf346422e923e1709ff1bf051073ba86f51b4338d6526f8da3f693330a03461b5&scene=21#wechat_redirect" >关于 Edgeware 锁仓合约的拒绝服务漏洞 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>。这个漏洞问题的本质在于<strong>对新建的锁仓合约的余额的这个条件进行竞争。</strong>攻击者可以监控所有链上的锁仓请求，提前计算出锁仓合约的地址，然后向合约地址转账，造成锁仓失败。在官方没有修复之前，要防止这种攻击，只能使用比攻击者更高的手续费让自己的锁仓交易先行打包，从而与攻击者形成竞争避免攻击。最后，官方修复方案为不对锁仓合约的余额进行强制性的相等检查，而是采用大于等于的形式，避免了攻击的发生。</p><h3 id="越权访问攻击-Exceed-Authority-Access-Attack"><a href="#越权访问攻击-Exceed-Authority-Access-Attack" class="headerlink" title="越权访问攻击 Exceed Authority Access Attack"></a>越权访问攻击 Exceed Authority Access Attack</h3><p>和传统安全的定义一样，<strong>越权指的是访问或执行超出当前账户权限的操作</strong>，如本来有些操作只能是合约管理员执行的，但是由于限制做得不严谨，导致关键操作也能被合约管理员以外的人执行，导致不可预测的风险，这种攻击在以太坊和 EOS 上都曾出现过多次。</p><p>以 EOS 上著名的 BetDice 游戏为例，由于在游戏合约内的路由(EOS 内可自定义的事件转发器)中没有对来源账号进行严格的校验，导致普通用户能通过 push action 的方式访问到合约中的关键操作 transfer 函数，<strong>直接绕过转账流程进行下注，从而发生了越权攻击</strong>，事后虽然 BetDice 官方紧急修复了代码，并严格限制了来源账号，但这个漏洞已经让攻击者几乎无成本薅走 BetDice 奖池内将近 5 万 EOS。又如在以太坊使用 solidity 版本为 0.4.x 进行合约开发的时候，很多合约开发者在对关键函数编写的时候不仅没有加上权限校验，也没有指定函数可见性，在这种情况下，函数的默认可见性为 public，恶意用户可以通过这些没有进行限制的关键函数对合约进行攻击。</p><h3 id="交易顺序依赖攻击-Transaction-Ordering-Attack"><a href="#交易顺序依赖攻击-Transaction-Ordering-Attack" class="headerlink" title="交易顺序依赖攻击 Transaction-Ordering Attack"></a>交易顺序依赖攻击 Transaction-Ordering Attack</h3><p>在区块链的世界当中，一笔交易内可能含有多个不同的交易，而这些交易执行的顺序会影响最终的交易的执行结果，由于在挖矿机制的区块链中，交易未被打包前都处于一种待打包的 pending 状态，如果能事先知道交易里面执行了哪些其他交易，恶意用户就能通过增加矿工费的形式，发起一笔交易，让交易中的其中一笔交易先行打包，扰乱交易顺序，造成非预期内的执行结果，达成攻击。以以太坊为例，假如存在一个 Token 交易平台，这个平台上的手续费是通过调控合约中的参数实现的，假如某天平台项目方通过一笔交易请求调高交易手续费用，这笔交易被打包后的所有买卖 Token 的交易手续费都要提升，正确的逻辑应该是从这笔交易开始往后所有的 Token 买卖交易的手续费都要提升，但是由于交易从发出到被打包存在一定的延时，请求修改交易手续费的交易不是立即生效的，那么这时恶意用户就可以以更高的手续费让自己的交易先行打包，避免支付更高的手续费。</p><h3 id="女巫攻击-Sybil-Attack"><a href="#女巫攻击-Sybil-Attack" class="headerlink" title="女巫攻击 Sybil Attack"></a>女巫攻击 Sybil Attack</h3><p>传闻中女巫是一个会魔法的人，一个人可以幻化出多个自己，令受害人以为有多人，但其实只有一个人。在区块链世界中，<strong>女巫攻击(Sybil Attack)是针对服务器节点的攻击</strong>。攻击发生时候，通过某种方式，某个恶意节点可以伪装成多个节点，对被攻击节点发出链接请求，达到节点的最大链接请求，导致节点没办法接受其他节点的请求，造成节点拒绝服务攻击。以 EOS 为例，慢雾安全团队曾披露过的 EOS P2P 节点拒绝服务攻击实际上就是女巫攻击的一种，攻击者可以非常小的攻击成本来达到瘫痪主节点的目的。详情可参考:</p><p><a class="link"   href="https://github.com/slowmist/papers/blob/master/EOSIO-P2P-Sybil-Attack/zh.md" >https://github.com/slowmist/papers/blob/master/EOSIO-P2P-Sybil-Attack/zh.md <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><p>建议在搭建全节点的情况下，服务器需要在系统层面上对网络连接情况进行监控，一旦发现某个IP连接异常就调用脚本配置 iptables 规则屏蔽异常的 IP，同时链开发者在进行公链开发时应该在 P2P 模块中对单 IP 节点连接数量添加控制。</p><h3 id="假错误通知攻击-Fake-Onerror-Notification-Attack"><a href="#假错误通知攻击-Fake-Onerror-Notification-Attack" class="headerlink" title="假错误通知攻击 Fake Onerror Notification Attack"></a>假错误通知攻击 Fake Onerror Notification Attack</h3><p>EOS 上存在各种各样的通知，只要在 action 中<strong>添加 require_recipient 命令</strong>，就能对指定的帐号通知该 action，在 EOS 上某些智能合约中，为了用户体验或其他原因，一般会对 onerror 通知进行某些处理。如果这个时候没有对 onerror 通知的来源合约是否是 eosio 进行检验的话，就能使用和<strong>假转账</strong>通知同样的手法对合约进行攻击，触发合约中对 onerror 的处理，从而导致被攻击合约资产遭受损失。</p><h3 id="粉尘攻击-Dusting-Attack"><a href="#粉尘攻击-Dusting-Attack" class="headerlink" title="粉尘攻击 Dusting Attack"></a>粉尘攻击 Dusting Attack</h3><p>粉尘攻击(Dusting Attack)最早发生于比特币网络当中，所谓粉尘，指的是<strong>交易中的交易金额相对于正常交易而言十分地小，可以视作微不足道的粉尘。</strong>通常这些粉尘在余额中不会被注意到，许多持币者也很容易忽略这些余额。但是由于比特币或基于比特币模型的区块链系统的账本模型是采用 UTXO 模型作为账户资金系统，即用户的每一笔交易金额，都是通过消费之前未消费的资金来产生新的资金。别有用意的用户，就能通过这种机制，给大量的账户发送这些粉尘金额，令交易粉尘化，然后再通过追踪这些粉尘交易，关联出该地址的其他关联地址，通过对这些关联地址进行行为分析，就可以分析一个地址背后的公司或个人，破坏比特币本身的匿名性。除此之外，由于比特币网络区块容量大小的限制，大量的粉尘交易会造成区块的拥堵，从而使得交易手续费提升，进而产生大量待打包交易，降低系统本身的运行效率。</p><p>对于如何避免粉尘攻击，可以在构造交易的过程中，<strong>根据交易的类型，计算出交易的最低金额，同时对每个输出进行判断，如果低于该金额，则不能继续构造该笔交易。</strong>特别的，如果这个输出刚好发生在找零上，且金额对于你来说不太大，则可以通过舍弃该部分的粉尘输出，以充作交易手续费来避免构造出粉尘交易。其次，为了保护隐私性，慢雾安全团队建议可以在构造交易时把那些金额极小的 UTXO 舍弃掉，使用大额的 UTXO 组成交易。</p><h3 id="C2-攻击-C2-Attack"><a href="#C2-攻击-C2-Attack" class="headerlink" title="C2 攻击 C2 Attack"></a>C2 攻击 C2 Attack</h3><p>C2 全称 Command and Control，翻译过来就是<strong>命令执行与控制</strong>，在传统的网络攻击中，在通过各种漏洞进入到目标服务器后，受限于空间，通常通过网络拉取二段 exploit 进行驻留，实现后渗透流程。所以，C2 架构也就可以理解为，恶意软件通过什么样的方式获取资源和命令，以及通过什么样的方式将数据回传给攻击者。在传统的攻击手法中，攻击者一般通过远程服务器拉取命令到本地执行，但是这种方式也有很明显的缺点，就是一旦远程服务器被发现，后续渗透活动就无法正常进行。但是区块链网络提供了一个天然且不可篡改的大型数据库，攻击者通过把攻击荷载(payload)写进交易中，并通过发送交易把该命令永久的刻在区块链数据库中。通过这种方法，即使攻击命令被发现，也无法篡改链上数据，无需担心服务器被发现然后下线的风险。</p><h3 id="洗币-Money-Laundering"><a href="#洗币-Money-Laundering" class="headerlink" title="洗币 Money Laundering"></a>洗币 Money Laundering</h3><p>洗币和洗钱是一样的，只是对象不同，洗钱指的是将一笔非法得到的金钱通过某些操作后变成正当、合法的收入。而洗币也是一样，<strong>指的是将非法获取的代币，如通过黑客攻击、携带用户资产跑路或通过诈骗等手段获取的代币，通过某些手段，将其来源变成正当、合法的来源。</strong>如通过交易所进行洗币、智能合约中洗币或通过某些搅拌器进行中转、通过匿名币种如门罗币，Zcash 等，令非法所得的资金无法被追踪，最后成功逃过监管达到洗币的目的，然后通过把代币转换成法币离场，完成洗币的流程。</p><h3 id="勒索-Ransom"><a href="#勒索-Ransom" class="headerlink" title="勒索 Ransom"></a>勒索 Ransom</h3><p>勒索是传统行业中常见的攻击行为，攻击者通过向受害者主机发送<strong>勒索病毒</strong>对主机文件进行加密来向受害者进行资金勒索。随着区块链技术的发展，近年来，勒索开始呈现新的方式，如使用比特币作为勒索的资金支付手段或使用匿名性更高的门罗币作为资金支付手段。如著名的 GandCrab 病毒就是比特币勒索病毒，受害者需要向攻击者支付一定量的比特币换取解密私钥。通过这种勒索手段，GandCrab 勒索病毒一年就勒索了超过 20 亿美金。值得一提的是，就算向攻击者发送比特币，也不一定能换取解密私钥，造成“人财两空”的局面。除此之外，慢雾安全团队还捕获到某些攻击者通过发送勒索邮件，谎称检测到交易所的漏洞，需要支付一定金额的比特币才能提供解决方案。这种勒索方式也是区块链行业近来越来越流行的勒索手段。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;区块链安全入门&quot;&gt;&lt;a href=&quot;#区块链安全入门&quot; class=&quot;headerlink&quot; title=&quot;区块链安全入门&quot;&gt;&lt;/a&gt;区块链安全入门&lt;/h1&gt;&lt;p&gt;因为本人不是区块链出身，所以学习区块链安全之前先入门一下。上学期学的也比较乱，系统从头学习一下。&lt;/</summary>
      
    
    
    
    
    <category term="区块链安全" scheme="https://arieran.github.io/tags/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://arieran.github.io/2023/07/21/hello-world/"/>
    <id>https://arieran.github.io/2023/07/21/hello-world/</id>
    <published>2023-07-21T06:15:40.945Z</published>
    <updated>2023-07-21T06:15:40.945Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a class="link"   href="https://hexo.io/" >Hexo <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>! This is your very first post. Check <a class="link"   href="https://hexo.io/docs/" >documentation <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> for more info. If you get any problems when using Hexo, you can find the answer in <a class="link"   href="https://hexo.io/docs/troubleshooting.html" >troubleshooting <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> or you can ask me on <a class="link"   href="https://github.com/hexojs/hexo/issues" >GitHub <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure></div><p>More info: <a class="link"   href="https://hexo.io/docs/writing.html" >Writing <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure></div><p>More info: <a class="link"   href="https://hexo.io/docs/server.html" >Server <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure></div><p>More info: <a class="link"   href="https://hexo.io/docs/generating.html" >Generating <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure></div><p>More info: <a class="link"   href="https://hexo.io/docs/one-command-deployment.html" >Deployment <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a class=&quot;link&quot;   href=&quot;https://hexo.io/&quot; &gt;Hexo &lt;i class=&quot;fa-regular fa-arrow-up-right-from-square fa-sm&quot;&gt;&lt;/i&gt;&lt;/a&gt;! This is yo</summary>
      
    
    
    
    
  </entry>
  
</feed>
